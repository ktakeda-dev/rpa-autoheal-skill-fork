# Browser Automation Framework
## Claude AI × Playwright による次世代ブラウザ自動化

---

## 1. 核心メッセージ（3つの価値）

> **「作って、試して、直す」を全部AIがやる**

### ① 誰でも作れる（作成）
> **自然言語で指示するだけで、AIがワークフローを自動生成**

- 「このURLで経費申請するワークフローを作って」と言うだけ
- AIがブラウザを開いて画面を見ながらYAMLを生成
- プログラミング知識ゼロでOK

### ② 決定論的で高速 + その場でリカバリ（確実な業務遂行）
> **RPA並みの速度で実行、失敗してもAIがその場で回復して業務を完了**

- YAMLから最適化されたコードを自動生成 → AI推論なしで直接実行（決定論的）
- 毎回同じ動作を保証、結果がブレない
- 従来RPA: 高速だがUIが変わると止まる
- AIエージェント: 変化に強いが遅い、毎回AIが判断するので結果がブレる
- 本フレームワーク: 高速・確実 + 失敗時だけAIが状況を見てリカバリ
- **決定論的な高速実行と、変化対応力を両立**

### ③ 失敗から学習（自己改善）
> **失敗パターンを学習し、YAMLを自動修正 → 同じ失敗は二度としない**

- 失敗原因を特定してレポート生成
- 「直して」と言えばYAMLを自動修正
- 次回からは高速実行で成功
- **他ツール**: 失敗したら「失敗しました」で終わり、学習しない

---

### 他ツールとの比較

| ツール | 作成 | 実行速度 | リカバリ（その場） | 自己改善（次回） |
|--------|-----|---------|------------------|-----------------|
| Power Automate Desktop | AI支援 | 高速 | 停止 | 手動修正 |
| AIエージェント系（Browser-Use, Copilot Studio等） | AI | 遅い | AIが再試行 | なし（毎回AI判断） |
| **本フレームワーク** | **AI** | **高速** | **AIが回復** | **自動でYAML修正** |

---

## 2. 仕組み: Skill + YAML

### 2.1 Skill = Claude への「教育」

```
SKILL.md に書いておくこと:
  - このプロジェクトの目的
  - 使えるツール（Playwright MCP）
  - ワークフローの書き方
  - エラー時の対処法

→ 一度教えれば、Claude は「専門家」として振る舞う
→ 誰でも使える
→ 組織のナレッジとして永続化
```

| 他のAIツール | 知識の蓄積 | 専門性 |
|-------------|----------|--------|
| ChatGPT | セッション限り | 汎用 |
| Computer Use | なし | 汎用 |
| **Claude Code + Skill** | **永続的** | **ドメイン特化** |

### 2.2 YAML = コードより圧倒的に読みやすい手順書

```yaml
name: ログイン処理
steps:
  - name: サイトを開く
    action: navigate
    url: https://example.com

  - name: ユーザー名入力
    action: fill
    selector: "#username"
    value: "{{input.username}}"

  - name: ログインボタン押下
    action: click
    selector: "button[type='submit']"
```

- コードより圧倒的に読みやすい
- **わからなければ Claude に「これ何してるの？」と聞ける**
- Git管理で変更履歴を追跡

---

## 3. 技術詳細

### 3.1 ハイブリッド実行アーキテクチャ

#### なぜこの設計か？

AI駆動の自動化には2つの極端なアプローチがある：

```
極端A: 毎回AIが判断（Browser-Use, Skyvern 等）
  → 柔軟だが、遅い・高コスト・不安定

極端B: 固定スクリプト実行（従来のRPA）
  → 高速だが、失敗したら止まる
```

**本フレームワークは「両方の良いとこ取り」を実現する。**

#### YAML → コード生成 → 高速実行

```
workflows/expense.yaml（人間が読める定義）
           ↓ 自動変換
generated/expense.template.js（Playwright コード）
           ↓ 直接実行
ブラウザ操作（AI推論なし・高速）
```

- YAMLを毎回解釈するのではなく、**事前にPlaywrightコードへ変換**
- ネイティブコードとして実行するため、高速かつ確実
- 生成コードは `generated/` に保存され、監査・デバッグ可能

#### 失敗時のみ AI が介入（MCP経由）

```
生成コード実行 ───→ 成功 ───→ 完了（AIコスト: ゼロ）
       │
       ↓ 失敗
AI が MCP 経由でブラウザのスナップショット取得
       ↓
現在の画面状態を理解
       ↓
   ┌───┴────┬──────────────┬──────────────┐
   ↓        ↓              ↓              ↓
別セレクタ   予期しない      エラー内容を    ユーザーに
で再試行    ダイアログを閉じる  読んで対処     確認を求める
```

従来のRPAは失敗したら停止するか、単純リトライするだけ。
本フレームワークは **AIが状況を見て、人間のように判断して回復** する。

**「普段は高速・低コストで動き、困った時だけAIが助ける」** という設計。

### 3.2 自己改善ループ（学習する自動化）

#### フォールバック → 学習 → 改善 のサイクル

```
┌────────────────────────────────────────────────────────────┐
│                    自己改善ループ                          │
│                                                            │
│  ① 生成コード実行 → 失敗                                  │
│         ↓                                                  │
│  ② AI がフォールバック介入 → その場で回復                 │
│         ↓                                                  │
│  ③ 学習レポート自動生成                                   │
│     - 何が失敗したか                                       │
│     - なぜ失敗したか（セレクタ変更？タイミング？）         │
│     - どう修正すべきか                                     │
│         ↓                                                  │
│  ④ ユーザー：「その通りに直して」                         │
│         ↓                                                  │
│  ⑤ YAML + 生成コードが自動修正                            │
│         ↓                                                  │
│  ⑥ 次回からは高速実行で成功（同じ失敗は二度と起きない）   │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

#### 学習レポートの例

```markdown
## 実行レポート: myte-expense-entertainment

### 失敗したステップ
Step 7: Amount を入力
  - セレクタ: #amount_input
  - エラー: Element not found

### AI の回復アクション
スナップショットを確認 → セレクタが #expense-amount に変更されていた
代替セレクタで入力成功

### 推奨される修正
workflows/myte-expense-entertainment.yaml の Step 7:
  - 変更前: selector: "#amount_input"
  - 変更後: selector: "#expense-amount"

### 適用方法
「この修正を適用して」と言ってください
```

#### なぜこれが強力か

```
従来の RPA:
  失敗 → 停止 → 人間が原因調査 → 人間が修正 → 再デプロイ
  （数時間〜数日）

本フレームワーク:
  失敗 → AI回復 → レポート生成 → 「直して」 → 自動修正
  （数分）
```

**使えば使うほど、失敗パターンを学習して強くなる。**
**同じ失敗は二度と起きない。**

これは単なる自動化ではなく、**自己進化する自動化システム**。

### 3.3 Task によるスケーラビリティ

```
通常のAI:
  1件目処理 → 2件目 → ... → 15件目でコンテキスト溢れ → 失敗

Task 分離:
  メインコンテキスト（クリーンに保持）
       ├─→ Task 1 → 結果だけ返却
       ├─→ Task 2 → 結果だけ返却
       └─→ Task 30 → 結果だけ返却

→ 何件でも安定して処理可能
```

---

## 4. 組織への価値

### 4.1 ナレッジの蓄積

```
従来:
  個人のノウハウ → 属人化 → 退職で消失

本フレームワーク:
  ノウハウ → Skill + YAML → Git管理 → 組織資産
```

### 4.2 自動化の民主化

```
Before: 自動化 = 開発者の仕事
After:  自動化 = 誰でも自然言語でできる
```

### 4.3 拡張性

```
Skill/MCP を追加するだけで機能拡張:
  - 新しい Skill → 新しいドメイン知識
  - 新しい MCP → 新しいツール連携（Slack、Google Drive 等）

→ コードを書かずに機能を増やせる
```

### 4.4 コスト効率

```
従来の AI 自動化:
  API 従量課金 → 実行するたびにコスト発生

本フレームワーク:
  Claude Code サブスク内で実行 → 追加の従量課金なし
```

---

## 5. 将来構想

### 5.1 選択的AI実行（Selective AI Execution）

```
現在: 失敗時のみAI介入

将来: ステップごとに「AI判断」か「固定実行」かを選べる
  - 固定の操作 → RPA（高速・低コスト）
  - 画面を見て判断が必要な操作 → AI（毎回推論）
```

**例: ECサイトで商品を探してカートに入れる**

| ステップ | 実行方式 | 理由 |
|---------|---------|------|
| サイトを開く | RPA | 固定URL |
| 検索キーワード入力 | RPA | 決まった値を入れるだけ |
| **検索結果から選択** | **AI** | 結果が毎回変わる、条件判断が必要 |
| カートに追加 | RPA | ボタンクリックだけ |

**「基本はRPA、画面を見て判断する箇所だけAI」という最適バランス。**

### 5.2 Task の並列実行

```
並列実行（API等の独立した処理）:
  メインコンテキスト
       ├─→ Task A ─┐
       ├─→ Task B ─┼─→ 同時実行 → 結果を集約
       └─→ Task C ─┘

→ 処理時間を大幅短縮
```

### 5.3 自動化範囲の拡大

```
ブラウザ自動化だけでなく:
  - デスクトップアプリ操作（Excel、社内システム等）
  - ファイル操作（PDF生成、データ変換）
  - 複数システム連携（ブラウザ + デスクトップ + API）

→ 同じ Skill + YAML の仕組みで統一的に自動化
→ 学習済みのナレッジを他の自動化にも応用可能
```

---

## 6. まとめ

### 3つの核心価値

| 価値 | 説明 |
|------|------|
| **① 誰でも作れる（作成）** | 自然言語で指示するだけでワークフロー生成 |
| **② 決定論的で高速 + その場でリカバリ（確実な業務遂行）** | RPA並みの速度 + 失敗してもAIが回復 |
| **③ 失敗から学習（自己改善）** | 同じ失敗は二度としない、次回から高速成功 |

### + 組織への価値

| 価値 | 説明 |
|------|------|
| **ナレッジ蓄積** | Skill + YAML = 永続的な組織資産 |
| **スケーラビリティ** | Task分離で大量処理も安定 |
| **拡張性** | Skill/MCP追加で機能拡張可能 |
| **コスト効率** | Claude Codeサブスク内で実行、従量課金なし |

> **「作って、試して、直す」を全部AIがやる自動化**
