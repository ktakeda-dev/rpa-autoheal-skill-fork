# スペック要件: ブラウザ自動化ワークフローの決定論的YAML→JS変換

## 初期説明

ブラウザ自動化ワークフローのYAML→JS変換方式を変更したい。

### 現状
- YAML→JS変換はAIが行っている
- AIがYAMLを様々な方法で解釈している（条件文など）

### 目標状態
- YAMLは厳密なスキーマに従う
- JS変換はスクリプトで決定論的に行う（AIではなく）
- YAMLが正しければ、JS出力は決定論的
- 条件文などのロジックはYAMLで明確に定義
- MCP経由の`browser_code`と`run-workflow.js`の両方で動作

## 要件に関する議論

### 質問と回答

**Q1:** スキーマ検証はいつ行うべきか？YAML生成時か変換時か？
**回答:** YAML生成時（AIが作成する時）に検証。AIがYAMLを生成→スキーマに対して検証→無効なら修正。JS変換は機械的・決定論的なステップとなる。

**Q2:** 条件ロジックのYAML形式は？
**回答:** AIが生成しやすく、機械的にJSに変換できる構造化形式を使用。例：`when: { field: "extract.amount", op: ">", value: 10000 }`

**Q3:** `playwright_code`ブロックはどう扱うか？
**回答:** そのまま生成JSにコピー。実行時の失敗はAIアシスタンスが引き続きサポート。

**Q4:** 生成JSはMCP `browser_code`と`run-workflow.js`の両方で動作すべきか？
**回答:** はい。両環境で同じJSが動作。両方ともPlaywright Page APIを使用するため互換性の問題なし。

**Q5:** 変数補間を1つの形式に標準化できるか？
**回答:** はい。AIが入力処理を担当するため標準化可能。機能は失われない。

**Q6:** アーキテクチャはどう分割すべきか？
**回答:**
- 変換フェーズ（本スペック）：YAML→JS決定論的変換スクリプト
- 実行フェーズ（既存）：変更なし

**Q7:** エラーハンドリングのアプローチは？
**回答:**
- フォールバックは絶対に必要
- ビルド時検証：明確なエラーで即座に失敗
- ただし、YAML生成時に検証するため、実際にはビルド失敗は発生しないはず

**Q8:** 実行フェーズに含めるべき機能は？
**回答:**
- AIアシスト時の自動修復
- AIアシスト時の学習レポート

### 参照すべき既存コード

明示的に特定された類似機能はなし。ただし、既存コードベースには以下が含まれる：
- 現在のYAMLワークフロー定義
- run-workflow.js実行ロジック
- MCP browser_code統合

### フォローアップ質問

**Q9:** `fallback.mode`フィールドの扱いは？
**回答:** `mode: ai_search`は未使用であることが判明。削除する。フォールバック時は`name`と`hint`を使用してAIが要素を特定する。`hint`はステップ直下に移動し、`fallback`ネストを廃止する。

## ビジュアル素材

### 提供ファイル：
なし

### ビジュアルからの洞察：
該当なし

## 要件サマリー

### 機能要件

1. **スキーマ定義**
   - ブラウザ自動化ワークフロー用の厳密なYAMLスキーマを定義
   - スキーマは現在のワークフロー機能をすべてサポート
   - 条件ロジックは構造化形式：`when: { field: "...", op: "...", value: ... }`
   - `fallback.mode`を廃止し、`hint`をステップ直下に移動

2. **決定論的変換スクリプト**
   - スクリプトが検証済みYAMLを実行可能なJSに変換
   - 変換中のAI解釈なし
   - 同じ入力YAMLは常に同じ出力JSを生成
   - `playwright_code`ブロックはそのまま出力にコピー

3. **検証フロー**
   - AIがYAMLワークフローを生成
   - AIが厳密なスキーマに対してYAMLを検証
   - AIがスキーマ違反を修正
   - 検証済みYAMLのみが変換に進む

4. **変数補間**
   - 単一形式に標準化
   - AIがYAML生成前に入力処理を担当

5. **実行互換性**
   - 生成JSはMCP browser_code環境で動作
   - 生成JSはrun-workflow.js環境で動作
   - 両方ともPlaywright Page APIを使用（互換性レイヤー不要）

6. **AIアシスト機能（実行フェーズ）**
   - AIアシスタンス有効時の自動修復
   - AIアシスタンス有効時の学習レポート

### 再利用の機会

- 既存のPlaywright Page APIパターン
- run-workflow.jsの現在のワークフロー実行ロジック
- MCP browser_code統合パターン

### スコープ境界

**スコープ内：**
- 厳密なYAMLスキーマ定義
- 決定論的YAML→JS変換スクリプト
- 構造化条件ロジック形式（`when`句）
- 変数補間の標準化
- 明確なエラーメッセージ付きビルド時検証
- MCPとrun-workflow.js両方の実行コンテキストサポート
- フォールバック構造の簡素化（`fallback.mode`廃止、`hint`をステップ直下に）

**スコープ外：**
- 実行フェーズロジックの変更
- 自動修復動作の変更
- 学習レポート生成の変更
- 変換中のAI解釈（明示的に削除）

### 技術的考慮事項

- **アーキテクチャ分割**: 変換フェーズ（本スペック）と実行フェーズ（既存）の明確な分離
- **エラーハンドリング**: ビルド時に明確なエラーで即座に失敗（ただし生成時の検証により実際には発生しないはず）
- **互換性**: 両実行環境がPlaywright Page APIを使用するため、互換性問題は想定されない
- **スキーマ厳密性**: YAMLはスキーマに完全に準拠する必要あり。有効なYAML生成はAIの責任

### 主要な実装フロー

```
1. AIがYAMLを生成
2. AIが厳密なスキーマに対してYAMLを検証
3. AIがスキーマ違反を修正
4. YAMLの妥当性が保証される
5. 決定論的スクリプトがYAMLをJSに変換（AI解釈なし）
6. JSがブラウザで実行（有効時はAIアシスタンスが失敗をサポート）
```
